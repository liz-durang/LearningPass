{
  "language": "Solidity",
  "sources": {
    "contracts/CourseManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./QuestionManager.sol\";\nimport \"./StakingManager.sol\";\nimport \"./MyLearningNFT.sol\";\nimport \"./RewardManager.sol\";\nimport \"./MyPassport.sol\";\n\n\ncontract CourseManager {\n    struct Course {\n        string name;\n        string description;\n        string courseType;\n        string provider;\n        uint256 enrolledStudents;\n        uint256 completedStudents;\n        uint256[] questionIds; // IDs of questions associated with this course\n        uint256 stakingRequirement; // how many staking requires\n        uint256 nftsIssued; // how many nft issued\n\n        mapping(address => bool) students; // Tracks enrolled students\n        mapping(address => uint256) studentProgress; // Tracks number of questions answered by each student\n        mapping(address => uint256) studentStartTime; // Tracks when each student started the course\n        mapping(address => bool) studentCompleted; // Nuevo mapeo para estudiantes que completaron el curso\n    }\n\n    string public constant contractTag = \"Course Manager Contract!\";\n    mapping(uint256 => Course) public courses;\n    uint256 public courseCount;\n    address public owner;\n\n    QuestionManager public questionManager; // Instance of QuestionManager contract\n    StakingManager public stakingManager; // Instance of StakingManager contract\n    MyLearningNFT public myLearningNFT; // Instance of MyLearningNFT contract\n    RewardManager public rewardManager; // Instance of MyLearningNFT contract\n    MyPassport public myPassport; // Instance of MyPassport contract\n    \n\n\n    event CourseCreated(uint256 courseId, string name, address provider,uint256 stakingRequirement );\n    event StudentEnrolled(uint256 courseId, address student,  uint256 stakingRequirement);\n    event StudentUnenrolled(uint256 courseId, address student );\n    event QuestionAddedToCourse(uint256 courseId, uint256 questionId);\n    event QuestionAnswered(uint256 courseId, address student, uint256 questionId);\n\n\n\n    modifier courseExists(uint256 courseId) {\n        require(courseId < courseCount, \"Course does not exist\");\n        _;\n    }\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    modifier onlyOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Only the owner can perform this action\");\n\t\t_;\n\t}\n\n    // Constructor: Called once on contract deployment\n    constructor(\n        address _owner, \n        address _questionManagerAddress, \n        address payable _stakingContractAddress, \n        address _nftContractAddress, \n        address _rewardManagerAddress,\n        address _myPassportAddress\n    ) {\n\t\towner = _owner;\n        questionManager = QuestionManager(_questionManagerAddress);\n        stakingManager = StakingManager(_stakingContractAddress);\n        myLearningNFT = MyLearningNFT(_nftContractAddress);\n        rewardManager = RewardManager(_rewardManagerAddress);\n        myPassport = MyPassport(_myPassportAddress);\n\t}\n\n    function createCourse(string memory _name, string memory _description, uint256 _stakingRequirement, string memory _courseType, string memory _provider) public {\n        Course storage newCourse = courses[courseCount];\n        newCourse.name = _name;\n        newCourse.description = _description;\n        newCourse.courseType = _courseType;\n        newCourse.provider = _provider;\n        newCourse.enrolledStudents = 0;\n        newCourse.stakingRequirement = _stakingRequirement;\n\n        emit CourseCreated(courseCount, _name, msg.sender, _stakingRequirement);\n        courseCount++;\n    }\n\n    function enroll(address _student, uint256 _courseId) public payable courseExists(_courseId) {\n        Course storage course = courses[_courseId];\n        require(!course.students[_student], \"Already enrolled\");\n        require(msg.value == course.stakingRequirement, \"Incorrect staking amount\");\n        \n        // Verificar si el estudiante tiene un pasaporte\n        require(myPassport.isPassportValid(_student), \"Student must have a passport to enroll\");\n\n        // Deposit the stake into the staking contract and pass the courseId\n        stakingManager.depositCourseStake{value: msg.value}(_student, _courseId);\n\n        course.students[_student] = true;\n        course.enrolledStudents++;\n        course.studentStartTime[_student] = block.timestamp; // Registrar la fecha y hora de inicio\n\n        emit StudentEnrolled(_courseId, _student, msg.value);\n    }\n\n    function unenroll(address _student, uint256 _courseId) public courseExists(_courseId) {\n        Course storage course = courses[_courseId];\n        require(course.students[_student], \"Not enrolled\");\n\n        course.students[_student] = false;\n        course.enrolledStudents--;\n\n        emit StudentUnenrolled(_courseId, _student);\n    }\n\n    function isEnrolled(uint256 _courseId, address _student) public view courseExists(_courseId) returns (bool) {\n        return courses[_courseId].students[_student];\n    }\n\n    function getCourseDetails(uint256 _courseId) public view courseExists(_courseId) returns (string memory, string memory, string memory, uint256, uint256, string memory) {\n        Course storage course = courses[_courseId];\n        return (course.name, course.description, course.provider, course.enrolledStudents, course.stakingRequirement, course.courseType);\n    }\n\n    // Function to create a new question and add it to a course\n    function createAndAddQuestionToCourse(\n        uint256 _courseId, \n        string memory _questionText, \n        string[] memory _options, \n        uint256 _correctOptionIndex\n    ) public courseExists(_courseId) {\n        // Create a new question in the QuestionManager\n        questionManager.addQuestion(_questionText, _options, _correctOptionIndex);\n        \n        // Get the ID of the newly created question (it will be questionCount - 1)\n        uint256 newQuestionId = questionManager.questionCount() - 1;\n        \n        // Add the new question to the course\n        courses[_courseId].questionIds.push(newQuestionId);\n        \n        emit QuestionAddedToCourse(_courseId, newQuestionId);\n    }\n\n\n    // Function to retrieve the questions of a course\n    function getCourseQuestions(uint256 _courseId) public view returns (uint256[] memory) {\n        require(_courseId < courseCount, \"Invalid course ID\");\n        return courses[_courseId].questionIds;\n    }\n\n    // Function to answer a question within a course\n    function answerCourseQuestion(uint256 _courseId, uint256 _questionIndex, uint256 _optionIndex, address _student) public returns (bool) {\n        require(_courseId < courseCount, \"Invalid course ID\");\n\n        Course storage course = courses[_courseId];\n        uint256 questionId = course.questionIds[_questionIndex];\n        require(course.students[msg.sender], \"Not enrolled in the course\");\n\n        bool correct = questionManager.answerQuestion(questionId, _optionIndex, _student);\n\n        if (correct) {\n            course.studentProgress[_student]++;\n            emit QuestionAnswered(_courseId, _student, questionId);\n        }\n\n        return correct;\n    }\n\n    // Method to get the progress of a student in a course\n    function getStudentProgress(uint256 _courseId, address _student) public view courseExists(_courseId) returns (uint256 progressPercentage) {\n        Course storage course = courses[_courseId];\n        require(course.students[_student], \"Student not enrolled in the course\");\n\n        uint256 totalQuestions = course.questionIds.length;\n        if (totalQuestions == 0) {\n            return 0;\n        }\n\n        uint256 answeredQuestions = course.studentProgress[_student];\n        progressPercentage = (answeredQuestions * 100) / totalQuestions;\n    }\n\n    // Withdraw the stake for a student (after course completion or other conditions) and mintNFT\n    function finishCourse(uint256 _courseId, address _student) public courseExists(_courseId) {\n        Course storage course = courses[_courseId];\n        require(course.students[_student], \"Not enrolled in the course\");\n        require(course.questionIds.length > 0, \"The course must have at least one question\");\n        require(course.studentProgress[_student] == course.questionIds.length, \"Course not completed\");\n\n        // Withdraw the stake from the staking contract for the specific course\n        //stakingManager.withdrawStakeCourse(_student, _courseId);\n\n        // Mint NFT of the student\n        myLearningNFT.mint(_student);\n        course.nftsIssued++;\n\n        //claim reward\n        this.claimRewardTime(_courseId, _student);\n\n        // Marcar al estudiante como completado\n        course.studentCompleted[_student] = true;\n        course.completedStudents++; // Incrementar el contador de estudiantes completados\n\n        course.students[_student] = false;\n        course.enrolledStudents--;\n\n        \n    }\n\n    //Get how many NFT issued by course\n    function getNftsIssued(uint256 _courseId) public view courseExists(_courseId) returns (uint256) {\n        return courses[_courseId].nftsIssued;\n    }\n\n    // Retrieve the enrollment date of a student in a course\n    function getStudentStartTime(uint256 _courseId, address _student) public view courseExists(_courseId) returns (uint256) {\n        require(courses[_courseId].students[_student], \"Student not enrolled in the course\");\n        return courses[_courseId].studentStartTime[_student];\n    }\n    \n    // Create a reward of time for a course\n    function createRewardTime(uint256 _courseId, uint256 _amount, uint256 _timeLimit, string memory _description) public payable{\n        require(_courseId < courseCount, \"Invalid course ID\");\n        \n        string memory provider = courses[_courseId].provider;\n        // Llama a la función de rewardManager con los parámetros correctos\n        rewardManager.createRewardTime{value: msg.value}(_courseId, _amount, _timeLimit, provider, _description);\n    }\n\n    // Create a reward of attemps for a course\n    function createRewardAttemp(uint256 _courseId, uint256 _amount, uint256 _attemps, string memory _description) public payable{\n        require(_courseId < courseCount, \"Invalid course ID\");\n        \n        string memory provider = courses[_courseId].provider;\n        // Llama a la función de rewardManager con los parámetros correctos\n        rewardManager.createRewardAttemp{value: msg.value}(_courseId, _amount, _attemps, provider, _description);\n    }\n    \n    \n    // Claim Reward of time to students rewards\n    function claimRewardTime(uint256 _courseId, address _student) public {\n        Course storage course = courses[_courseId];\n        require(course.students[_student], \"Not enrolled in the course\");\n\n        uint256 completionTime = block.timestamp;\n\n        require(course.studentProgress[_student] == course.questionIds.length, \"Course not completed\");\n\n        rewardManager.claimRewardTime(_courseId, _student, completionTime);\n    }\n\n    function withdrawRewardTime(address _user, uint256 _courseId) public {\n        rewardManager.withdrawRewardTime(_user, _courseId);\n    }\n\n     // Nueva función para consultar cursos en los que un estudiante está inscrito\n    function getEnrolledCourses(address _student) public view returns (uint256[] memory) {\n        uint256[] memory enrolledCourses = new uint256[](courseCount);\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < courseCount; i++) {\n            if (courses[i].students[_student]) {\n                enrolledCourses[count] = i;\n                count++;\n            }\n        }\n\n        // Ajuste el tamaño de la matriz para que coincida con el número real de cursos inscritos\n        uint256[] memory result = new uint256[](count);\n        for (uint256 j = 0; j < count; j++) {\n            result[j] = enrolledCourses[j];\n        }\n\n        return result;\n    }\n    //temp para devolver los cursos\n    struct CourseSummary {\n        uint256 courseId;\n        string name;\n        string description;\n        string provider;\n        string courseType;\n        uint256 enrolledStudents;\n        uint256 stakingRequirement;\n    }\n\n\n    function getAllCourses() public view returns (CourseSummary[] memory) {\n    CourseSummary[] memory allCourses = new CourseSummary[](courseCount);\n\n    for (uint256 i = 0; i < courseCount; i++) {\n        Course storage course = courses[i];\n        allCourses[i] = CourseSummary(\n            i,\n            course.name,\n            course.description,\n            course.provider,\n            course.courseType,\n            course.enrolledStudents,\n            course.stakingRequirement\n        );\n    }\n\n    return allCourses;\n    }\n\n    function getCompletedStudentsCount(uint256 _courseId) public view courseExists(_courseId) returns (uint256) {\n        return courses[_courseId].completedStudents;\n    }\n\n    // Función para verificar si un estudiante ha completado el curso\n    function hasStudentCompletedCourse(uint256 _courseId, address _student) public view courseExists(_courseId) returns (bool) {\n        return courses[_courseId].studentCompleted[_student];\n    }\n\n\n}\n"
    },
    "contracts/MyLearningNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract MyLearningNFT {\n    // Eventos estándar de ERC721\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    // Mappings para almacenar la propiedad y las aprobaciones\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Nombre y símbolo del token\n    string public name;\n    string public symbol;\n\n    string public constant contractTag = \"MyLearningNFT Contract!\";\n\n    // Contador para el ID de token\n    uint256 private _tokenIdCounter;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    // Función para consultar el propietario de un token\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"Token no existe\");\n        return owner;\n    }\n\n    // Función para consultar el balance de tokens de un propietario\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"Consulta para la direccion cero\");\n        return _balances[owner];\n    }\n\n    // Función para aprobar a otra dirección para transferir un token\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"Aprobacion al propietario actual\");\n        require(msg.sender == owner, \"No tienes permiso para aprobar este token\");\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    // Función para transferir un token a otra dirección\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"No tienes permiso para transferir este token\");\n        require(ownerOf(tokenId) == from, \"No es el propietario actual del token\");\n        require(to != address(0), \"Transferencia a la direccion cero\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    // Función para mintear un nuevo token\n    function mint(address to) public {\n        require(to != address(0), \"Direccion cero no permitida\");\n        \n        uint256 tokenId = _tokenIdCounter;\n        _tokenIdCounter += 1;\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    // Función para verificar si alguien es propietario o aprobado para un token\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || _tokenApprovals[tokenId] == spender);\n    }\n\n    // Función interna para realizar la transferencia de un token\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        // Borra la aprobación anterior\n        delete _tokenApprovals[tokenId];\n        emit Transfer(from, to, tokenId);\n    }\n}"
    },
    "contracts/MyPassport.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract MyPassport {\n    \n    // State Variables\n    struct Passport {\n        string fullName;\n        uint256 issueDate;\n        string bio;\n        bool isValid;\n        string userId;\n    }\n\n    string public constant contractTag = \"MyPassport Contract!\";\n    mapping(address => Passport) public passports;\n    mapping(address => mapping(string => bool)) public roles; // Mapping (usuario => (rol => existe))\n    mapping(address => string[]) private userRoles;\n    address public immutable owner;\n    address public admin;\n\n    // Events: a way to emit log statements from smart contract that can be listened to by external parties\n    event PassportIssued(address indexed owner, string fullName, uint256 issueDate);\n    event PassportRevoked(address indexed owner);\n    event RoleAssigned(address indexed user, string role);\n    event RoleRevoked(address indexed user, string role);\n    event AdminAdded(address indexed newAdmin);\n    event AdminRemoved(address indexed admin);\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    modifier isOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Not the Owner\");\n\t\t_;\n\t}\n\n    // Modifier: to restrict access to admin functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not the admin\");\n        _;\n    }\n\n    // Constructor: Called once on contract deployment\n    constructor(address _owner) {\n\t\towner = _owner;\n        admin = _owner;\n\t}\n\n     // Register a new passport for an individual\n    function issuePassport(address _user, string memory _fullName, string memory _bio, string memory _userId) public {\n        require(!passports[_user].isValid, \"Passport already exists for this address\");\n\n\n        passports[_user] = Passport({\n            fullName: _fullName,\n            issueDate: block.timestamp,\n            bio: _bio,\n            isValid: true,\n            userId: _userId\n        });\n\n        this.assignRole(_user, \"student\");\n\n        emit PassportIssued(_user, _fullName, block.timestamp);\n    }\n    \n     // Revoke an existing passport\n    function revokePassport(address _user) public onlyAdmin{\n        require(passports[_user].isValid, \"Passport does not exist or is already revoked\");\n\n        passports[_user].isValid = false;\n\n        emit PassportRevoked(_user);\n    }\n\n\n\n    // Check if a passport is valid\n    function isPassportValid(address _user) public view returns (bool) {\n        bool valid;\n        if(passports[_user].isValid){\n            valid = true;\n        }else{\n            valid = false;\n        }\n\n        return valid;\n    }\n\n    // Get passport details\n    function getPassportDetails(address _user) public view returns (string memory fullName, string memory bio, uint256 issueDate, bool isValid, string memory userId) {\n    \n    Passport memory passport = passports[_user];\n\n    require(passport.isValid, \"Passport does not exist or is invalid\");\n\n    return (passport.fullName, passport.bio, passport.issueDate, passport.isValid, passport.userId);\n}\n\n    // Assign a role to a passport\n    function assignRole(address _user, string memory _role) public {\n        require(passports[_user].isValid, \"Passport does not exist\");\n        require(!roles[_user][_role], \"Role already assigned\"); // Verificar que no se duplique el rol\n\n        roles[_user][_role] = true; // Asignar el rol\n        userRoles[_user].push(_role); // Add the role to the user's role list\n        emit RoleAssigned(_user, _role);\n    }\n\n    // Revoke a role from a passport\n    function revokeRole(address _user, string memory _role) public onlyAdmin{\n        require(passports[_user].isValid, \"Passport does not exist\");\n        require(roles[_user][_role], \"Role does not exist for this user\"); // Verificar que el rol exista\n\n        roles[_user][_role] = false; // Revocar el rol\n        emit RoleRevoked(_user, _role);\n\n    }\n\n    // Check if a user has a specific role\n    function hasRole(address _user, string memory _role) public view returns (bool) {\n        require(passports[_user].isValid, \"Passport does not exist\");\n        return roles[_user][_role]; // Retornar el estado del rol\n    }\n\n    // Add a new admin (only owner)\n    function setAdmin(address _newAdmin) public onlyAdmin {\n        admin = _newAdmin;\n        emit AdminAdded(_newAdmin);\n    }\n\n    // Get all roles of a user\n    function getRoles(address _user) public view returns (string[] memory) {\n        require(passports[_user].isValid, \"Passport does not exist\");\n        return userRoles[_user]; // Return the list of roles\n    }\n}\n"
    },
    "contracts/QuestionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract QuestionManager {\n\n    string public constant contractTag = \"Question Manager Contract!\";\n    address public owner;\n\n    // Structure for the options of a question\n    struct Option {\n        string optionText;\n    }\n\n    // Structure of a question with multiple options and one correct answer\n    struct Question {\n        string questionText;\n        Option[] options;\n        uint256 correctOptionIndex; // Index of the correct option in the options array\n    }\n\n    // Mapping to store all questions\n    mapping(uint256 => Question) public questions;\n    uint256 public questionCount = 0;\n\n    // Mapping to store user answers\n    mapping(address => mapping(uint256 => uint256)) public userAnswers; // user address -> question ID -> selected option index\n\n    // Events\n    event QuestionCreated(uint256 questionId, string questionText);\n    event QuestionAnswered(uint256 questionId, bool isCorrect);\n    event UserAnswered(address user, uint256 questionId, uint256 selectedOptionIndex);\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    modifier isOwner() {\n        require(msg.sender == owner, \"Not the Owner\");\n        _;\n    }\n\n    // Constructor: Called once on contract deployment\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Function to add a new question with its options\n    function addQuestion(string memory _questionText, string[] memory _options, uint256 _correctOptionIndex) public {\n        require(_correctOptionIndex < _options.length, \"Correct option index out of bounds\");\n\n        Question storage question = questions[questionCount];\n        question.questionText = _questionText;\n        question.correctOptionIndex = _correctOptionIndex;\n\n        for (uint256 i = 0; i < _options.length; i++) {\n            question.options.push(Option({optionText: _options[i]}));\n        }\n\n        emit QuestionCreated(questionCount, _questionText);\n        questionCount++;\n    }\n\n    // Function to answer a question and check if it's correct\n    function answerQuestion(uint256 _questionId, uint256 _optionIndex, address _user) public returns (bool) {\n        require(_questionId < questionCount, \"Invalid question ID\");\n\n        Question memory question = questions[_questionId];\n        bool isCorrect = (_optionIndex == question.correctOptionIndex);\n\n        emit QuestionAnswered(_questionId, isCorrect);\n        emit UserAnswered(_user, _questionId, _optionIndex); // Emitir evento de respuesta del usuario\n\n        return isCorrect;\n    }\n\n    // Function to save user answer\n    function saveUserAnswer(uint256 _questionId, uint256 _selectedOption, address _user) public {\n        require(_questionId < questionCount, \"Invalid question ID\");\n        userAnswers[_user][_questionId] = _selectedOption; // Guardar la respuesta del usuario\n\n        emit UserAnswered(_user, _questionId, _selectedOption); // Emitir evento\n    }\n\n    // Function to get user answers for multiple questions\n    function getUserAnswers(uint256[] memory _questionIds, address _user) public view returns (uint256[] memory) {\n        uint256[] memory answers = new uint256[](_questionIds.length); // Inicializar el arreglo para las respuestas\n\n        for (uint256 i = 0; i < _questionIds.length; i++) {\n            require(_questionIds[i] < questionCount, \"Invalid question ID\");\n            answers[i] = userAnswers[_user][_questionIds[i]]; // Guardar la respuesta correspondiente\n        }\n\n        return answers; // Retorna el arreglo de respuestas\n    }\n\n    // Function to get the details of a question\n    function getQuestionDetails(uint256 _questionId) public view returns (string memory questionText, string[] memory options, uint256 correctOptionIndex) {\n        require(_questionId < questionCount, \"Invalid question ID\");\n\n        Question memory question = questions[_questionId];\n        questionText = question.questionText;\n        correctOptionIndex = question.correctOptionIndex;\n\n        options = new string[](question.options.length);\n        for (uint256 i = 0; i < question.options.length; i++) {\n            options[i] = question.options[i].optionText;\n        }\n\n        return (questionText, options, correctOptionIndex);\n    }\n\n    // Function to retrieve details for multiple questions based on an array of IDs\n    function getQuestionsDetails(uint256[] memory _questionIds)\n        public\n        view\n        returns (\n            string[] memory questionTexts,\n            string[][] memory allOptions,\n            uint256[] memory correctOptionIndices,\n            uint256[] memory ids\n        )\n    {\n        uint256 length = _questionIds.length;\n\n        // Initialize arrays to store each detail component\n        questionTexts = new string[](length);\n        allOptions = new string[][](length);\n        correctOptionIndices = new uint256[](length);\n        ids = new uint256[](length); // Inicializar el arreglo ids\n\n        for (uint256 i = 0; i < length; i++) {\n            uint256 questionId = _questionIds[i];\n            require(questionId < questionCount, \"Invalid question ID\");\n\n            Question memory question = questions[questionId];\n\n            // Store details for each question\n            questionTexts[i] = question.questionText;\n            correctOptionIndices[i] = question.correctOptionIndex;\n            ids[i] = questionId; // Asignar el ID de la pregunta\n\n            // Initialize options array for each question\n            string[] memory options = new string[](question.options.length);\n            for (uint256 j = 0; j < question.options.length; j++) {\n                options[j] = question.options[j].optionText;\n            }\n            allOptions[i] = options;\n        }\n\n        return (questionTexts, allOptions, correctOptionIndices, ids);\n    }\n\n}\n"
    },
    "contracts/RewardManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./StakingManager.sol\";\n\ncontract RewardManager {\n    struct Reward {\n        string description;\n        string rewardType;\n        uint256 totalAmount; //Amount for all the students\n        uint256 amount; // Amount of reward by student\n        uint256 timeLimit; // Time limit to earn the reward\n        uint256 attemp; //limit of attemp to earn a reward\n        bool exists; // Check if the reward exists\n        string provider;\n    }\n\n    string public constant contractTag = \"Reward Manager Contract!\";\n    address public owner;\n    uint256 public rewardCount;\n\n    mapping(uint256 => Reward[]) public rewards; // Rewards for each course\n\n    StakingManager public stakingManager;\n\n    event RewardCreated(uint256 courseId, uint256 amount);\n    event RewardClaimed(uint256 courseId, address student, uint256 amount);\n    event RewardRemoved(uint256 courseId, uint256 rewardIndex);\n    event RewardWithdrawn(address user, uint256 rewardIndex);\n\n\n    constructor(address _owner, address payable _stakingManagerAddress) {\n        owner = _owner;\n        stakingManager = StakingManager(_stakingManagerAddress);\n    }\n\n    function createRewardTime(uint256 _courseId, uint256 _amount, uint256 _timeLimit, string memory _provider, string memory _description) public payable{\n        require(_amount > 0, \"Reward amount must be greater than zero\");\n        require(msg.value > _amount, \"Total reward amount must be greater than amount\");\n\n        // Verificar si ya existe un Reward de tipo \"Time\" para este curso\n        uint256 existingRewardIndex;\n        bool exists = false;\n\n        try this.getRewardIndexByType(_courseId, \"Time\") returns (uint256 index) {\n            existingRewardIndex = index;\n            exists = true; // Si se encuentra, se establece exists a true\n        } catch {\n            exists = false; // Si no se encuentra, permanece false\n        }\n\n        require(!exists, \"Reward of type 'Time' already exists for this course\");\n\n        rewards[_courseId].push(Reward({\n            rewardType: \"Time\",\n            totalAmount: msg.value,\n            amount: _amount,\n            timeLimit: _timeLimit,\n            attemp: 0,\n            exists: true, \n            provider: _provider,\n            description: _description\n        }));\n\n        stakingManager.depositRewardStake{value: msg.value}(rewardCount);\n        rewardCount++;\n\n        emit RewardCreated(_courseId, _amount);\n    }\n\n    function createRewardAttemp(uint256 _courseId, uint256 _amount, uint256 _attemp, string memory _provider, string memory _description) public payable{\n        require(_amount > 0, \"Reward amount must be greater than zero\");\n        require(msg.value > _amount, \"Total reward amount must be greater than amount\");\n\n        // Verificar si ya existe un Reward de tipo \"Time\" para este curso\n        uint256 existingRewardIndex;\n        bool exists = false;\n\n        try this.getRewardIndexByType(_courseId, \"Attemp\") returns (uint256 index) {\n            existingRewardIndex = index;\n            exists = true; // Si se encuentra, se establece exists a true\n        } catch {\n            exists = false; // Si no se encuentra, permanece false\n        }\n\n        require(!exists, \"Reward of type 'Attemp' already exists for this course\");\n\n        rewards[_courseId].push(Reward({\n            rewardType: \"Attemp\",\n            totalAmount: msg.value,\n            amount: _amount,\n            timeLimit: 0,\n            attemp: _attemp,\n            exists: true, \n            provider: _provider,\n            description: _description\n        }));\n\n        stakingManager.depositRewardStake{value: msg.value}(rewardCount);\n        rewardCount++;\n\n        emit RewardCreated(_courseId, _amount);\n    }\n\n\n    function claimRewardTime(uint256 _courseId, address _student, uint256 _completionTime) public {\n        uint256 rewardIndex = getRewardIndexByType(_courseId, \"Time\");\n        \n        Reward storage reward = rewards[_courseId][rewardIndex];\n        require(reward.exists, \"Reward does not exist\");\n        require(_completionTime < reward.timeLimit, \"Completion time exceeds reward time limit\");\n\n        // Transferir la recompensa al estudiante\n        stakingManager.claimReward(_student, reward.amount, rewardIndex);\n\n        emit RewardClaimed(_courseId, _student, reward.amount);\n    }\n\n    // Function to allow the user to withdraw their specific reward\n    // Function to allow the user to withdraw their specific reward\n    function withdrawRewardTime(address _user, uint256 _courseId) public {\n        uint256 rewardIndex = getRewardIndexByType(_courseId, \"Time\");\n        \n        Reward storage reward = rewards[_courseId][rewardIndex];\n        require(reward.exists, \"Reward does not exist\");\n\n        // Comprobar que hay suficiente balance para el retiro\n        require(reward.amount > 0, \"No reward to withdraw.\");\n\n        // Lógica para retirar la recompensa del stakingManager\n        stakingManager.withdrawStakeReward(_user, rewardIndex);\n        reward.exists = false; // Marcar como no existente para evitar el retiro duplicado\n\n        emit RewardWithdrawn(_user, rewardIndex);\n    }\n\n\n\n    function getRewardAmount(uint256 _courseId, uint256 rewardIndex) public view returns (uint256) {\n        require(rewardIndex < rewards[_courseId].length, \"Reward index out of bounds\");\n        return rewards[_courseId][rewardIndex].amount;\n    }\n\n    function getRewardIndexByType(uint256 _courseId, string memory _rewardType) public view returns (uint256) {\n        Reward[] memory courseRewards = rewards[_courseId];\n        for (uint256 i = 0; i < courseRewards.length; i++) {\n            if (keccak256(abi.encodePacked(courseRewards[i].rewardType)) == keccak256(abi.encodePacked(_rewardType))) {\n                return i; // Retorna el índice si se encuentra\n            }\n        }\n        revert(\"Reward type not found\"); // Revertir si no se encuentra el tipo de recompensa\n    }   \n\n    function removeRewardTime(uint256 _courseId, uint256 _rewardIndex) public {\n        require(_rewardIndex < rewards[_courseId].length, \"Reward index out of bounds\");\n        Reward storage rewardToRemove = rewards[_courseId][_rewardIndex];\n        require(rewardToRemove.exists, \"Reward does not exist\");\n\n        // Mover el último elemento al índice que queremos eliminar y luego reducir el tamaño del array\n        rewards[_courseId][_rewardIndex] = rewards[_courseId][rewards[_courseId].length - 1];\n        rewards[_courseId].pop();\n\n        // Emitir evento de eliminación de recompensa\n        emit RewardRemoved(_courseId, _rewardIndex);\n    }\n\n    function rewardExists(uint256 _courseId, string memory _rewardType) internal view returns (bool) {\n        Reward[] memory courseRewards = rewards[_courseId];\n        for (uint256 i = 0; i < courseRewards.length; i++) {\n            if (keccak256(abi.encodePacked(courseRewards[i].rewardType)) == keccak256(abi.encodePacked(_rewardType))) {\n                return true;\n            }\n        }\n        return false; \n\n    }\n\n    function getAllRewardsByCourse(uint256 _courseId) public view returns (Reward[] memory) {\n    return rewards[_courseId];\n}\n\n\n\n\n\n   \n}\n"
    },
    "contracts/StakingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract StakingManager {\n    string public constant contractTag = \"Staking Manager Contract!\";\n    address public owner;\n\n    // Mapping to store the stake amount per user per course\n    mapping(address => mapping(uint256 => uint256)) public stakesCourses;\n\n    // Mapping to store all courses a user has stakes in \n    mapping(address => uint256[]) private userCourses;\n\n    //Mapping to store de stake amount per award \n    mapping(uint256 => uint256) public amountRewards;\n\n    // Mapping to store the stake amount per user per reward\n    mapping(address => mapping(uint256 => uint256)) public stakesRewards;\n\n    // Mapping to store all reward a user has claim in \n    mapping(address => uint256[]) private userRewards;\n\n    event CourseStakeDeposited(address indexed user, uint256 courseId, uint256 amount);\n    event CourseStakeWithdrawn(address indexed user, uint256 courseId, uint256 amount);\n    event RewardStakeDeposited(uint256 rewardId, uint256 amount);\n    event RewardStakeClaimed(address indexed user, uint256 amount);\n    event RewardStakeWithdrawn(address indexed user, uint256 rewardId, uint256 amount);\n    event ContractFunded(address indexed owner, uint256 amount);\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can perform this action\");\n        _;\n    }\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Function to deposit a stake for a specific course\n    function depositCourseStake(address _user, uint256 _courseId) public payable {\n        require(msg.value > 0, \"Stake must be greater than zero\");\n\n        // If this is the first stake for this course, add it to userCourses\n        if (stakesCourses[_user][_courseId] == 0) {\n            userCourses[_user].push(_courseId);\n        }\n\n        stakesCourses[_user][_courseId] += msg.value;\n        \n        emit CourseStakeDeposited(_user, _courseId, msg.value);\n    }\n\n    // Function to deposit a stake for a specific reward\n    function depositRewardStake(uint256 _rewardId) public payable {\n        require(msg.value > 0, \"Stake must be greater than zero\");\n        \n        // Sumar el nuevo depósito a la cantidad existente\n        amountRewards[_rewardId] += msg.value;\n\n        emit RewardStakeDeposited(_rewardId, msg.value);\n    }\n\n\n    // Function to user deposit rewards \n    function claimReward(address _user, uint256 amount, uint256 rewardIndex) public {\n        require(amount > 0, \"Reward amount must be greater than zero\");\n        require(address(this).balance >= amount, \"Insufficient contract balance\");\n\n        // Transferir la recompensa al estudiante\n        // Sumar la cantidad a las recompensas del usuario\n        \n\n        // If this is the first stake for this reward, add it to userRewards\n        if (stakesRewards[_user][rewardIndex] == 0) {\n            userRewards[_user].push(rewardIndex);\n        }\n        stakesRewards[_user][rewardIndex] += amount;\n\n        emit RewardStakeClaimed(_user, amount);\n    }\n\n    // Function to withdraw a user's stake for a specific course\n    function withdrawStakeCourse(address _user, uint256 _courseId) public {\n        uint256 stakedAmount = stakesCourses[_user][_courseId];\n        require(stakedAmount > 0, \"No stake to withdraw for this course\");\n\n        stakesCourses[_user][_courseId] = 0;\n        payable(_user).transfer(stakedAmount);\n        emit CourseStakeWithdrawn(_user, _courseId, stakedAmount);\n    }\n    \n\n    // Function to withdraw a user's stake for a specific reward\n    function withdrawStakeReward(address _user, uint256 _rewardId) public {\n        uint256 stakedAmount = stakesCourses[_user][_rewardId];\n        require(stakedAmount > 0, \"No stake to withdraw for this reward\");\n\n        stakesRewards[_user][_rewardId] = 0;\n        payable(_user).transfer(stakedAmount);\n        emit RewardStakeWithdrawn(_user, _rewardId, stakedAmount);\n    }\n    \n\n    // Check the amount of staked ETH for a user in a specific course\n    function getStakeCourse(address _user, uint256 _courseId) public view returns (uint256) {\n        return stakesCourses[_user][_courseId];\n    }\n\n    // Function to get the total stake of a user across all courses\n    // Function to get the total stake of a user across all courses and count the number of courses\n    function getTotalStakeCourses(address _user) public view returns (uint256 totalStake, uint256 courseCount) {\n        uint256[] memory courses = userCourses[_user];\n        courseCount = 0; // Inicializa el contador de cursos\n        totalStake = 0; // Inicializa el total de stakes\n\n        for (uint256 i = 0; i < courses.length; i++) {\n            uint256 stakeAmount = stakesCourses[_user][courses[i]];\n            if (stakeAmount > 0) { // Solo cuenta los cursos con un stake mayor a 0\n                totalStake += stakeAmount;\n                courseCount++; // Incrementa el contador de cursos\n            }\n        }\n    }\n\n    // Allow the contract to receive Ether\n    receive() external payable {}\n\n     // Function to fund the contract\n    function fundContract() public payable {\n        require(msg.value > 0, \"Funding amount must be greater than zero\");\n        emit ContractFunded(msg.sender, msg.value); // Emitir evento al fondear el contrato\n    }\n\n    // Function to get the balance of the contract\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance; // Retorna el balance actual del contrato en wei\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}